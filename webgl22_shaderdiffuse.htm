<html>
<head>
<title>GLC WebGL</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3      at_pos;							// input position from rendering pipe line
	attribute vec4      at_dif;							// input diffuse from rendering pipe line

	varying   vec4      vr_dif;							// output to fragment processing

	void main(void) {
		gl_Position = vec4(at_pos, 1.0);
		vr_dif = at_dif;
	}
</script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

	varying   vec4      vr_dif;							// input from vertex processing

    void main(void) {
        gl_FragColor = vr_dif;
    }
</script>


<script type="text/javascript">

function FindShader(gl, id)								// find the shader script
{
	var shaderScript = document.getElementById(id);
	if (!shaderScript)
	{
		return null;
	}

	var str = "";
	var k = shaderScript.firstChild;
	while (k)
	{
		if (k.nodeType == 3)							// text node type
		{
			str += k.textContent;
		}
		k = k.nextSibling;
	}

	var shader;
	if (shaderScript.type == "x-shader/x-fragment")
	{
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	}
	else if (shaderScript.type == "x-shader/x-vertex")
	{
		shader = gl.createShader(gl.VERTEX_SHADER);
	}
	else
	{
		return null;
	}

	gl.shaderSource(shader, str);
	gl.compileShader(shader);

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
	{
		alert(gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}


// global common variable

var gl;											// gl context object
var mouse = {x: 0, y: 0};						// mouse position

var g_program;								// shader program

var wgb_pos;
var wgb_dif;


var vtx_pos =
[
   -0.9, -0.9,  0.0,
	0.9, -0.9,  0.0,
	0.9,  0.9,  0.0,
   -0.9,  0.9,  0.0
];

var vtx_dif =
[
   1.0, 0.0, 0.0, 1.0,
   0.0, 1.0, 0.0, 1.0,
   0.0, 0.0, 1.0, 1.0,
   1.0, 0.0, 1.0, 1.0
];


function WebGLInit(native_win)
{
	native_win.addEventListener('mousemove', function(e)
	{
		var rect = native_win.getBoundingClientRect();

		mouse.x = e.clientX - rect.left;
		mouse.y = e.clientY - rect.top;
	}, false);

	setInterval("WebGLRender()", 0);

	gl.clearColor(0.0, 0.4, 0.6, 1.0);



	// create program
	var shader_vtx = FindShader(gl, "shader-vs");	//alert(shader_vtx);
	var shader_frg = FindShader(gl, "shader-fs");	//alert(shader_frg);

	g_program = gl.createProgram();
	gl.attachShader(g_program, shader_vtx);
	gl.attachShader(g_program, shader_frg);
	gl.linkProgram(g_program);

	if (!gl.getProgramParameter(g_program, gl.LINK_STATUS))
	{
		alert("Could not initialise shaders");
	}


	g_program.vertexPositionAttribute = gl.getAttribLocation(g_program, "at_pos");
	g_program.vertexColorAttribute    = gl.getAttribLocation(g_program, "at_dif");



	// create sqare vertexbuffer position
	wgb_pos = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, wgb_pos);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtx_pos), gl.STATIC_DRAW);
	wgb_pos.itemSize = 3;			// vector size
	wgb_pos.numItems = 4;			// item number


	// create sqare vertexbuffer diffuse
	wgb_dif = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, wgb_dif);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtx_dif), gl.STATIC_DRAW);
	wgb_dif.itemSize = 4;			// vector size
	wgb_dif.numItems = 4;			// item number
}




function WebGLRender()
{
	document.title = "mouse: " + mouse.x +", " +mouse.y;

	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);



	gl.useProgram(g_program);												// use program

	gl.disable( gl.DEPTH_TEST);												// disable depth test
	gl.disable( gl.CULL_FACE );												// disalbe culling face


	gl.enableVertexAttribArray(g_program.vertexPositionAttribute);			// enable to vertex array index for position
	gl.bindBuffer(gl.ARRAY_BUFFER, wgb_pos);								// bind buffer to pipe line
	gl.vertexAttribPointer(g_program.vertexPositionAttribute, wgb_pos.itemSize, gl.FLOAT, false, 0, 0);



	gl.enableVertexAttribArray(g_program.vertexColorAttribute);				// enable to vertex array index for diffuse
	gl.bindBuffer(gl.ARRAY_BUFFER, wgb_dif);								// bind buffer to pipe line
	gl.vertexAttribPointer(g_program.vertexColorAttribute   , wgb_dif.itemSize, gl.FLOAT, false, 0, 0);



	gl.drawArrays(gl.TRIANGLE_FAN, 0, wgb_pos.numItems);	// draw..


	// disable client-side capability
	gl.disableVertexAttribArray(g_program.vertexPositionAttribute);
	gl.disableVertexAttribArray(g_program.vertexColorAttribute   );


	gl.useProgram(null);												// use program


	gl.flush();
}


function WebGLStart()
{
	// setup the body
	document.body.style.border  = 'none';
	document.body.style.margin  = '0';
	document.body.style.padding = '0';

	// create the dynamic native_win
	var native_win = document.createElement("canvas");
	native_win.width  = 800;
	native_win.height = 480;
	document.body.appendChild(native_win);

	// initialize gl context
	try
	{
		gl = native_win.getContext("experimental-webgl");
		gl.viewportWidth  = native_win.width;
		gl.viewportHeight = native_win.height;
	}
	catch (e)
	{
	}

	if (!gl)
	{
		alert("Could not initialise WebGL. check the browser");
	}


	WebGLInit(native_win);

	setInterval("WebGLRender()", 0);
}
</script>
</head>

<body onload="WebGLStart();">
</body>
</html>
